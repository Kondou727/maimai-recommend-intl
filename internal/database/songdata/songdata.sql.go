// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: songdata.sql

package songdatadb

import (
	"context"
	"database/sql"
)

const createChartStatCN = `-- name: CreateChartStatCN :exec
INSERT INTO chartstatscn (
    song_id, diff, count, std_dev
)
VALUES (
    ?, ?, ?, ?
)
ON CONFLICT (song_id, diff) DO NOTHING
`

type CreateChartStatCNParams struct {
	SongID int64
	Diff   string
	Count  int64
	StdDev float64
}

func (q *Queries) CreateChartStatCN(ctx context.Context, arg CreateChartStatCNParams) error {
	_, err := q.db.ExecContext(ctx, createChartStatCN,
		arg.SongID,
		arg.Diff,
		arg.Count,
		arg.StdDev,
	)
	return err
}

const createSong = `-- name: CreateSong :exec
INSERT INTO songdata (
    id, title, artist, genre, img, release, version, is_dx, diff, level, const, is_utage, is_buddy
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT (id, diff, is_dx, is_utage) DO NOTHING
`

type CreateSongParams struct {
	ID      string
	Title   string
	Artist  string
	Genre   string
	Img     string
	Release string
	Version string
	IsDx    bool
	Diff    string
	Level   string
	Const   interface{}
	IsUtage bool
	IsBuddy sql.NullString
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) error {
	_, err := q.db.ExecContext(ctx, createSong,
		arg.ID,
		arg.Title,
		arg.Artist,
		arg.Genre,
		arg.Img,
		arg.Release,
		arg.Version,
		arg.IsDx,
		arg.Diff,
		arg.Level,
		arg.Const,
		arg.IsUtage,
		arg.IsBuddy,
	)
	return err
}

const createSongCN = `-- name: CreateSongCN :exec
INSERT INTO songdatacn (
    id, diff, title, is_dx
)
VALUES (
    ?, ?, ?, ?
)
ON CONFLICT (id, diff) DO NOTHING
`

type CreateSongCNParams struct {
	ID    int64
	Diff  string
	Title string
	IsDx  bool
}

func (q *Queries) CreateSongCN(ctx context.Context, arg CreateSongCNParams) error {
	_, err := q.db.ExecContext(ctx, createSongCN,
		arg.ID,
		arg.Diff,
		arg.Title,
		arg.IsDx,
	)
	return err
}

const returnAllJackets = `-- name: ReturnAllJackets :many
SELECT img FROM songdata
`

func (q *Queries) ReturnAllJackets(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, returnAllJackets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var img string
		if err := rows.Scan(&img); err != nil {
			return nil, err
		}
		items = append(items, img)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
